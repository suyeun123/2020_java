package com.ict.java02;

public class Ex01 {

	
	/*
		 1. 클래스는 무엇으로~ (3가지쓰시오) -> 멤버필드, 생성자, 멤버메소드
 			- 멤버필드(변수와 상수) : 데이터 (값)
	 		변수 : 언제든지 변할 수 있는 데이터
	 		상수 : 한번 저장되면 변경할 수 없는 데이터
		예)
		private String name;
		private int age ;
		private double weight;
		private boolean gender;
	
	 - 생성자 : 클래스를 객체로 만들 때 반드시 호출해야 되는 것
	     목적 : 멤버 필드의 초기값의 지정하는 것이 목적
		 구조특징 : 클래스와 같은이름을 사용한다.
		 			반환형이 없는 메소드와 같다.
		 		
		-> 한클래스에서 생성자를 여러개 가질수 있다.(생성자 오버로드)
		-> 인자가 없는 생성자를 기본생성자
		-> 만약에 생성자를 만들지 않으면 해당 클래스를 객체로 만들때
		   기본 생성자를 사용해야 된다.
		   그런데 생성자가 존재하면 존재하는 생성자로 만들어야 한다.
		   
	 	-> 생성자를 객체로 만드는 방법
			클래스이름 참조변수 = new 생성자
			
		
	- 멤버메소드 : 기능, 동작, 하는 것, 작동
	       -> 메소드를 호출하면 어떠한 내용을 실행(동작)한다.
	       -> 한 클래스에서 같은 이름의 여러 메소드가 여러개 존재-> 오버로드
	       -> 반환형 : 어떠한 행동을 한 후 반드시 자기를 호출한 곳으로 되돌아간다.
	       				내용을 가지고 가면 반환형이 있다.
	       				 그 내용의 자료형을 반환형 이라고 한다.
	       				 만약에 내용을 가지고 가지 않으면 반환형이 없는 것이다.
	       				 이렇게 반환형이 없으면 void라고 쓴다.
	       				 
	       -> getter() : 메소드를 호출한 곳에서 무언가를 얻어낼때 사용
	       -> setter() : 메소드를 이용해서 멤버 변수의 데이터를 변경할 때 사용
	       
	       
	       
	2. 클래스를 객체로 생성할때 초기화를 목적으로 반드시 호출하는것은?
	-> 생성자 :  [특징]  클래스와 같은이름을 사용한다.
		 		         반환형이 없는 메소드와 같다.
		 			
	
	3. 같은 이름의 메소드가 여러개 존재?
	
	답) 오버로딩(오버로드)

	
	이름이 같은데 오류가 나지않는 이유는?
	
	- 인자의 갯수나 자료형이 다르면 오류가 안난다.
	
	4. 상속관계에서 부모클래스의 메소드를 자식클래스가 가져와서 자식 클래스 상황에 맞게 변경하는것을?
	
		답 ) 오버라이딩
	
	    상속 : 클래스와 클래스와의 관계를 말하는데
	    		부모클래스 : super   
	    		자식클래스 : sub
	    		
	    		자식클래스가 부모클래스의 멤버필드와 멤버메소드를 객체 생성없이
	    		마음대로 사용 할 수 있도록 관계를 맺는것
	    		
	    		
	오버라이딩 : 자식클래스가 부모클래스의 메소드를 가지고 와서 변경해서 사용
	파이널(예약어) :   
	 - final 클래스  : 상속을 못하게 한다. 자식클래스를 못만든다.
	 - final 메소드  : 오버라이딩을 못하게한다. (변경해서 쓸수가 없다)
	 - final 변수    : (상수) 데이터, 값변경이 안된다.
	
	
	5. 추상클래스와 인터페이스에 대해서~
	
	 - 추상 클래스 : 추상메소드를 한개이상 가지고 있는 클래스 
	      추상메소드란 ? 메소드의 내용(몸통 = body)가 존재하지 않은 메소드 

	       일반 메소드 : public 반환형 이름 ([인자]) {실행할 내용}
	       추상메소드 : public 반환형 이름([인자]) ;  
	       
	       * 추상메소드나 추상 클래스이면 무조건 abstract예약어를 사용해야 된다.
	       예) public abstract class Unit{    -> 추상클래스
	                 public abstract void decEnergy();    -> 추상메소드

	       ** 추상클래스를 상속받은 일반 클래스는 무조건 추상메소드를 오버라이딩 해야된다.**
	       
	       		예) 
	       
	 - 인터페이스  : 상수와 추상메소드로만 이루어졌다.
	 				 객체생성할 수 없다.
	 				 interface 예약어를 사용한다.
	 				 
	 				 예)
	 				 public interface Ex01 {
	 				 상수와 추상메소드
	 				 }   
	 
	 ** 인터페이스에서는 예약어(abstract)를 안써도 오류가 안난다.**
	 *** 인터페이스를 상속 받은 클래스는 무조건 오버라이딩 해야된다. ***
	 
			public Ex02 implements Ex01 {
			
			@Override      -> 상속받은 클래스 반드시 오버라이딩 
			public void play(){
			}
			
			@Override
			public void sound(){
			
			
			
			}

	    
	 
	 
	 
	
	
	
	
		*/
}
